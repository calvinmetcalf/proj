{"ts":1357157560044,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function toGeoJSON(data,cb){\r\n    var outPut = { \"type\": \"FeatureCollection\",\r\n  \"features\": []};\r\n    var fl = data.features.length;\r\n    var i = 0;\r\n    while(fl>i){\r\n     var ft = data.features[i];\r\n/* as only ESRI based products care if all the features are the same type of geometry, check for geometry type at a feature level*/\r\n     var outFT = {\r\n            \"type\": \"Feature\",\r\n            \"properties\":prop(ft.attributes)\r\n        };\r\n        if(ft.attributes.OBJECTID){\r\n         outFT.id=ft.attributes.OBJECTID;\r\n        }\r\n        if(ft.geometry.x){\r\n//check if it's a point\r\n          outFT.geometry=point(ft.geometry);\r\n        }else if(ft.geometry.points){\r\n//check if it is a multipoint\r\n            outFT.geometry=points(ft.geometry);\r\n            }else if(ft.geometry.paths){\r\n//check if a line (or \"ARC\" in ESRI terms)\r\n         outFT.geometry=line(ft.geometry);\r\n        }else if(ft.geometry.rings){\r\n//check if a poly.\r\n           outFT.geometry=poly(ft.geometry);  \r\n        }\r\n        \r\n     outPut.features.push(outFT);\r\n     i++;\r\n    }\r\nfunction point(geometry){\r\n//this one is easy\r\n    return {\"type\": \"Point\",\"coordinates\": [geometry.x,geometry.y]};    \r\n}\r\nfunction points(geometry){\r\n//checks if the multipoint only has one point, if so exports as point instead\r\n    if(geometry.points.length===1){\r\n        return {\"type\": \"Point\",\"coordinates\": geometry.points[0]};\r\n    }else{\r\n        return { \"type\": \"MultiPoint\",\"coordinates\":geometry.points}; \r\n    }\r\n}\r\nfunction line(geometry){\r\n//checks if their are multiple paths or just one\r\n    if(geometry.paths.length===1){\r\n        return {\"type\": \"LineString\",\"coordinates\": geometry.paths[0]};\r\n    }else{\r\n        return { \"type\": \"MultiLineString\",\"coordinates\":geometry.paths}; \r\n    }\r\n}\r\nfunction poly(geometry){\r\n//first we check for some easy cases, like if their is only one ring\r\n    if(geometry.rings.length===1){\r\n        return {\"type\": \"Polygon\",\"coordinates\": geometry.rings};\r\n    }else{\r\n/*if it isn't that easy then we have to start checking ring direction, basically the ring goes clockwise its part of the polygon, if it goes counterclockwise it is a hole in the polygon, but geojson does it by haveing an array with the first element be the polygons and the next elements being holes in it*/\r\n        var ccc= dP(geometry.rings);\r\n        var d = ccc[0];\r\n        var dd = ccc[1];\r\n        var r=[];\r\n        if(dd.length===0){\r\n/*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/\r\n            var l2 = d.length;\r\n            var i3 = 0;\r\n            while(l2>i3){\r\n             r.push([d[i3]]);   \r\n            }\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":r}; \r\n        }else if(d.length===1){\r\n/*if their is only one clockwise ring then we know all holes are in that poly*/\r\n            dd.unshift(d[0]);\r\n            return {\"type\": \"Polygon\",\"coordinates\": dd};\r\n            \r\n        }else{\r\n/*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":d, \"holes\":dd};\r\n        }  \r\n    }\r\n}\r\nfunction dP(a){\r\n//returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise\r\n    var d = [];\r\n        var dd =[];\r\n        var l = a.length;\r\n        var ii = 0;\r\n        while(l>ii){\r\n            if(c(a[ii])){\r\n                d.push(a[ii]);\r\n            }else{\r\n             dd.push(a[ii]);\r\n            }\r\n         ii++;\r\n        }\r\n    return [d,dd];\r\n}\r\nfunction c(a){\r\n//return true if clockwise\r\n var l = a.length-1;\r\n var i = 0;\r\n var o=0;\r\n\r\n while(l>i){\r\n o+=(a[i][0]*a[i+1][1]-a[i+1][0]*a[i][1]);\r\n   \r\n     i++;\r\n }\r\n    return o<=0;\r\n}  \r\nfunction prop(a){\r\n var p = {};\r\n for(var k in a){\r\n  if(a[k]){\r\n   p[k]=a[k];   \r\n  }\r\n }\r\n return p;\r\n}\r\nif(cb){\r\n cb(outPut)\r\n}else{\r\nreturn outPut;  \r\n}\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":4028}]],"length":4028}
{"contributors":[],"silentsave":false,"ts":1357157645572,"patch":[[{"diffs":[[0,"erties\":"],[-1,"prop("],[0,"ft.attri"]],"start1":404,"start2":404,"length1":21,"length2":16},{"diffs":[[0,"tributes"],[-1,")"],[0,"\r\n      "]],"start1":417,"start2":417,"length1":17,"length2":16},{"diffs":[[0,"};\r\n"],[-1,"        if(ft.attributes.OBJECTID){\r\n         outFT.id=ft.attributes.OBJECTID;\r\n        }\r\n"],[0,"    "]],"start1":435,"start2":435,"length1":99,"length2":8},{"diffs":[[0,"    "],[-1,"var ccc= dP"],[1,"return decodePolygon"],[0,"(geo"]],"start1":2205,"start2":2205,"length1":19,"length2":28},{"diffs":[[0,"    "],[-1,"    var d = ccc[0]"],[1,"}\r\n}\r\nfunction decodePolygon(a){\r\n//returns the feature\r\n    var coords = [],type"],[0,";\r\n    "],[-1,"  "],[-1,"  "],[0,"var "],[-1,"dd = ccc[1];\r\n    "],[1,"len = a.length;\r\n"],[0,"    var "],[-1,"r=[]"],[1,"i = 0"],[0,";\r\n    "],[-1,"    if(dd.length===0){\r\n/*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/\r\n            var l2 = d.length"],[1,"var len2 = coords.length-1;\r\n    while(len>i){\r\n        if(ringIsClockwise(a[i])){\r\n            coords.push([a[i]])"],[0,";\r\n "]],"start1":2248,"start2":2248,"length1":245,"length2":252},{"diffs":[[0,"    "],[-1,"var i3 = 0"],[1,"len2++"],[0,";\r\n "]],"start1":2507,"start2":2507,"length1":18,"length2":14},{"diffs":[[0,"    "],[-1,"    while(l2>i3){\r\n             r.push([d[i3]]);   \r\n   "],[1,"}else{\r\n         coords[len2].push(a[i]);\r\n"],[0,"        "],[-1," "],[0,"}\r\n     "],[-1,"       return { \"type\": \"MultiPolygon\",\"coordinates\":r}; "],[1,"i++;"],[0,"\r\n    "],[-1," "],[-1,"   }else if(d.length===1){\r\n/*if their is only one clockwise ring then we know all holes are in that poly*/\r\n            dd.unshift(d[0])"],[1,"}\r\n    if(coords.length===1){\r\n        type=\"Polygon\";\r\n    }else{\r\n        type=\"MultiPolygon\""],[0,";\r\n    "],[-1,"   "],[1,"}\r\n"],[0,"    "],[-1," "],[0,"retu"]],"start1":2524,"start2":2524,"length1":297,"length2":186},{"diffs":[[0,"urn {\"type\":"],[-1," \"Polygon\""],[1,"type"],[0,",\"coordinate"]],"start1":2709,"start2":2709,"length1":34,"length2":28},{"diffs":[[0,"es\":"],[-1," dd};\r\n            \r\n        }else{\r\n/*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":d, \"holes\":dd};\r\n        }  \r\n    }\r\n}\r\nfunction dP(a){\r\n//returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise\r\n    var d = [];\r\n        var dd =[];\r\n        var l = a.length;"],[1,"coords};\r\n}\r\n/*determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\r\n   or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\r\n   points-are-in-clockwise-order\r\n   this code taken from http://esri.github.com/geojson-utils/src/jsonConverters.js by James Cardona (MIT lisense)\r\n   */\r\n  function ringIsClockwise(ringToTest) {\r\n    var total = 0,"],[0,"\r\n  "]],"start1":2736,"start2":2736,"length1":523,"length2":476},{"diffs":[[0,"    "],[-1,"var i"],[0,"i = 0"],[-1,";"],[1,","],[0,"\r\n  "]],"start1":3214,"start2":3214,"length1":19,"length2":14},{"diffs":[[0,"    "],[-1,"while(l>ii){\r\n            if(c(a[ii])){\r\n                d.push(a[ii])"],[1,"rLength = ringToTest.length,\r\n        pt1 = ringToTest[i],\r\n        pt2"],[0,";\r\n    "],[-1," "],[-1,"       }else{\r\n             dd.push(a[ii]);\r\n            }\r\n         ii++;\r\n        }\r\n    return [d,dd];\r\n}\r\nfunction c(a){\r\n//return true if clockwise\r\n var l = a.length-1;\r\n var i = 0;\r\n var o=0;\r\n\r\n while(l>i){\r\n o+=(a[i][0]*a[i+1][1]-a[i+1][0]*a[i]"],[1,"for (i; i < rLength - 1; i++) {\r\n      pt2 = ringToTest[i + 1];\r\n      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1"],[0,"[1])"]],"start1":3230,"start2":3230,"length1":339,"length2":199},{"diffs":[[0,"\n   "],[-1,"\r\n"],[0,"   "],[-1,"  i++;\r\n }\r\n    return o<=0;\r\n}  \r\nfunction prop(a){\r\n var p = {};\r\n for(var k in a){\r\n  if(a[k]){\r\n   p[k]=a[k];   \r\n  }\r\n }\r\n return p;\r\n"],[1,"pt1 = pt2;\r\n    }\r\n    return (total >= 0);\r\n  "],[0,"}\r\ni"]],"start1":3431,"start2":3431,"length1":152,"length2":58},{"diffs":[[0,"(outPut)"],[1,";"],[0,"\r\n}else{"]],"start1":3500,"start2":3500,"length1":16,"length2":17},{"diffs":[[0,"Put;  \r\n}\r\n}"],[1,"\r\nif (typeof module !== \"undefined\") module.exports = toGeoJSON;"]],"start1":3529,"start2":3529,"length1":12,"length2":76}]],"length":3605,"saved":false}
{"ts":1357157888829,"patch":[[{"diffs":[[0,"erties\":"],[1,"prop("],[0,"ft.attri"]],"start1":404,"start2":404,"length1":16,"length2":21},{"diffs":[[0,"tributes"],[1,")"],[0,"\r\n      "]],"start1":422,"start2":422,"length1":16,"length2":17},{"diffs":[[0,"        };\r\n"],[1,"        if(ft.attributes.OBJECTID){\r\n         outFT.id=ft.attributes.OBJECTID;\r\n        }\r\n"],[0,"        if(f"]],"start1":433,"start2":433,"length1":24,"length2":115},{"diffs":[[0,"    "],[-1,"return decodePolygon"],[1,"var ccc= dP"],[0,"(geo"]],"start1":2302,"start2":2302,"length1":28,"length2":19},{"diffs":[[0,"    "],[-1,"}\r\n}\r\nfunction decodePolygon(a){\r\n//returns the feature\r\n    var coords = [],type"],[1,"    var d = ccc[0]"],[0,";\r\n    "],[1,"  "],[1,"  "],[0,"var "],[-1,"len = a.length;\r\n"],[1,"dd = ccc[1];\r\n   "],[0,"    "],[1," "],[0,"var "],[-1,"i = 0"],[1,"r=[]"],[0,";\r\n    "],[-1,"var len2 = coords.length-1;\r\n    while(len>i){\r\n        if(ringIsClockwise(a[i])){\r\n            coords.push([a[i]]);\r\n            len2++;\r\n        }else{\r\n         coords[len2].push(a[i]);\r\n"],[1,"    if(dd.length===0){\r\n/*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/\r\n            var l2 = d.length;\r\n            var i3 = 0;\r\n            while(l2>i3){\r\n             r.push([d[i3]]);   \r\n   "],[0,"        "],[1," "],[0,"}\r\n     "],[-1,"i++;"],[1,"       return { \"type\": \"MultiPolygon\",\"coordinates\":r}; "],[0,"\r\n    "],[-1,"}\r\n"],[0,"    "],[-1,"if(coords"],[1,"}else if(d"],[0,".len"]],"start1":2336,"start2":2336,"length1":369,"length2":431},{"diffs":[[0,"){\r\n"],[-1,"        type=\"Polygon\";\r\n    }else{\r\n        type=\"MultiPolygon\""],[1,"/*if their is only one clockwise ring then we know all holes are in that poly*/\r\n            dd.unshift(d[0])"],[0,";\r\n    "],[-1,"}\r\n"],[1,"    "],[0,"    "]],"start1":2774,"start2":2774,"length1":82,"length2":128},{"diffs":[[0,"{\"type\":"],[-1,"type"],[1," \"Polygon\""],[0,",\"coordi"]],"start1":2909,"start2":2909,"length1":20,"length2":26},{"diffs":[[0,"es\":"],[-1,"coords};\r\n}\r\n/*determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\r\n   or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\r\n   points-are-in-clockwise-order\r\n   this code taken from http://esri.github.com/geojson-utils/src/jsonConverters.js by James Cardona (MIT lisense)\r\n   */\r\n  function ringIsClockwise(ringToTest) {\r\n"],[1," dd};\r\n            \r\n        }else{\r\n/*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":d, \"holes\":dd};\r\n        }  \r\n    }\r\n}\r\nfunction dP(a){\r\n//returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise\r\n    var d = [];\r\n        var dd =[];\r\n        var l = a.length;\r\n    "],[0,"    var "],[-1,"total"],[1,"ii"],[0," = 0"],[-1,","],[1,";"],[0,"\r\n  "]],"start1":2938,"start2":2938,"length1":476,"length2":544},{"diffs":[[0,"    "],[-1,"i = 0,\r\n        rLength = ringToTest.length,\r\n        pt1 = ringToTest[i],"],[1,"while(l>ii){\r\n            if(c(a[ii])){\r\n                d.push(a[ii]);\r\n            }else{\r\n             dd.push(a[ii]);"],[0,"\r\n  "]],"start1":3484,"start2":3484,"length1":82,"length2":129},{"diffs":[[0,"    "],[-1,"pt2;"],[1,"    }"],[0,"\r\n    "],[-1,"for (i; i < rLength - 1; i++) {\r\n      pt2 = ringToTest[i + 1];\r\n      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1"],[1,"     ii++;\r\n        }\r\n    return [d,dd];\r\n}\r\nfunction c(a){\r\n//return true if clockwise\r\n var l = a.length-1;\r\n var i = 0;\r\n var o=0;\r\n\r\n while(l>i){\r\n o+=(a[i][0]*a[i+1][1]-a[i+1][0]*a[i]"],[0,"[1])"]],"start1":3615,"start2":3615,"length1":131,"length2":208},{"diffs":[[0,"\n   "],[1,"\r\n"],[0,"   "],[-1,"pt1 = pt2;\r\n    }\r\n    return (total >= 0);\r\n  "],[1,"  i++;\r\n }\r\n    return o<=0;\r\n}  \r\nfunction prop(a){\r\n var p = {};\r\n for(var k in a){\r\n  if(a[k]){\r\n   p[k]=a[k];   \r\n  }\r\n }\r\n return p;\r\n"],[0,"}\r\ni"]],"start1":3825,"start2":3825,"length1":58,"length2":152},{"diffs":[[0,"(outPut)"],[-1,";"],[0,"\r\n}else{"]],"start1":3988,"start2":3988,"length1":17,"length2":16},{"diffs":[[0,"}\r\n}"],[-1,"\r\nif (typeof module !== \"undefined\") module.exports = toGeoJSON;"]],"start1":4024,"start2":4024,"length1":68,"length2":4}]],"length":4028,"saved":false}
{"ts":1357158150984,"patch":[[{"diffs":[[0,"(ft."],[-1,"attributes.OBJECTID){\r\n         outFT.id=ft.attributes.OBJECTID;\r\n        }\r\n        if(ft."],[1,""],[0,"geom"]],"start1":455,"start2":455,"length1":99,"length2":8},{"diffs":[[0,"    "],[-1,"var ccc= dP"],[1,"return decodePolygon"],[0,"(geo"]],"start1":2211,"start2":2211,"length1":19,"length2":28},{"diffs":[[0,"    "],[-1,"    var d = ccc[0];\r\n        var dd = ccc[1]"],[1,"}\r\n}\r\nfunction decodePolygon(a){\r\n//returns the feature\r\n    var coords = [],type;\r\n    var len = a.length"],[0,";\r\n    "],[-1,"    "],[0,"var "],[-1,"r=[]"],[1,"i = 0"],[0,";\r\n    "],[-1,"    if(dd.length===0){\r\n/*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/\r\n            var l2 = d.length;\r\n            var i3 = 0;\r\n            while(l2>i3){\r\n             r.push([d[i3]]);   \r\n            }\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":r}; "],[1,"var len2 = coords.length-1;\r\n    while(len>i){\r\n        if(ringIsClockwise(a[i])){\r\n            coords.push([a[i]]);\r\n            len2++;\r\n        }else{\r\n         coords[len2].push(a[i]);\r\n        }\r\n     i++;"],[0,"\r\n    "],[1,"}\r\n"],[0,"    "],[-1,"}else if(d"],[1,"if(coords"],[0,".len"]],"start1":2254,"start2":2254,"length1":431,"length2":369},{"diffs":[[0,"){\r\n"],[-1,"/*if their is only one clockwise ring then we know all holes are in that poly*/"],[1,"        type=\"Polygon\";\r\n    }else{"],[0,"\r\n  "]],"start1":2630,"start2":2630,"length1":87,"length2":43},{"diffs":[[0,"    "],[-1,"    dd.unshift(d[0])"],[1,"type=\"MultiPolygon\""],[0,";\r\n    "],[-1,"    "],[1,"}\r\n"],[0,"    "]],"start1":2675,"start2":2675,"length1":39,"length2":37},{"diffs":[[0,"urn {\"type\":"],[-1," \"Polygon\""],[1,"type"],[0,",\"coordinate"]],"start1":2715,"start2":2715,"length1":34,"length2":28},{"diffs":[[0,"es\":"],[-1," dd};\r\n            \r\n        }else{\r\n/*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":d, \"holes\":dd};\r\n        }  \r\n    }\r\n}\r\nfunction dP(a){\r\n//returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise\r\n    var d = [];"],[1,"coords};\r\n}\r\n/*determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\r\n   or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\r\n   points-are-in-clockwise-order\r\n   this code taken from http://esri.github.com/geojson-utils/src/jsonConverters.js by James Cardona (MIT lisense)"],[0,"\r\n   "],[-1,"     var dd =[];\r\n        var l = a.length;"],[1,"*/\r\n  function ringIsClockwise(ringToTest) {\r\n    var total = 0,"],[0,"\r\n  "]],"start1":2742,"start2":2742,"length1":523,"length2":476},{"diffs":[[0,"    "],[-1,"var i"],[0,"i = 0"],[-1,";"],[1,","],[0,"\r\n  "]],"start1":3220,"start2":3220,"length1":19,"length2":14},{"diffs":[[0,"    "],[-1,"while(l>ii){\r\n            if(c(a[ii])){"],[1,"rLength = ringToTest.length,\r\n        pt1 = ringToTest[i],"],[0,"\r\n  "]],"start1":3236,"start2":3236,"length1":47,"length2":66},{"diffs":[[0,"    "],[-1,"        d.push(a[ii]);\r\n            }else{\r\n             dd.push(a[ii]);\r\n            }\r\n         ii++;"],[1,"pt2;\r\n    for (i; i < rLength - 1; i++) {"],[0,"\r\n      "],[-1,"  }\r\n    return [d,dd];\r\n}\r\nfunction c(a){\r\n//return true if clockwise\r\n var l = a.length-1;\r\n var i = 0;\r\n var o=0;\r\n\r\n while(l>i){\r\n o+=(a[i][0]*a[i+1][1]-a[i+1][0]*a[i]"],[1,"pt2 = ringToTest[i + 1];\r\n      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1"],[0,"[1])"]],"start1":3304,"start2":3304,"length1":290,"length2":131},{"diffs":[[0,"]);\r\n   "],[-1,"\r\n"],[0,"   "],[-1,"  i++;\r\n"],[1,"pt1 = pt2;\r\n   "],[0," }\r\n    "]],"start1":3433,"start2":3433,"length1":29,"length2":34},{"diffs":[[0,"urn "],[-1,"o<=0"],[1,"(total >= 0)"],[0,";\r\n"],[-1,"}"],[0,"  "],[1,"}"],[0,"\r\n"],[1,"  "],[0,"func"]],"start1":3470,"start2":3470,"length1":20,"length2":30},{"diffs":[[0,"(outPut)"],[-1,""],[1,";"],[0,"\r\n}else{"]],"start1":3615,"start2":3615,"length1":16,"length2":17},{"diffs":[[0,"Put;  \r\n}\r\n}"],[-1,""],[1,"\r\nif (typeof module !== \"undefined\") module.exports = toGeoJSON;"]],"start1":3644,"start2":3644,"length1":12,"length2":76}]],"length":3720,"saved":false}
